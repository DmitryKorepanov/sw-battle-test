# Known Issues and Limitations

## Architecture
- **Collision Logic Delegation:** `GameWorld` supports multiple units per cell and does not enforce collision rules. Blocking logic relies entirely on `BlockerComponent` checks within `MoveBehavior` and command handlers. Missing checks in new behaviors could lead to unintended unit stacking.
- **Implicit Targeting Logic:** Target selection currently relies on the presence of `HealthComponent` (see `features::utils::hasHealth`). This means any unit with health is automatically a valid target. Future extensions (Tower, Mine, etc.) likely require an explicit `AttackableComponent` / tags to distinguish "destructible" vs "valid AI target".
- **Event Emission Placement:** Event emission is split between `Behaviors` (attack, move, march-ended) and the orchestration layer (`main.cpp`) for unit death (after cleanup). This is consistent with "dead units disappear before the next turn", but it scatters responsibility for event emission. A future refinement could introduce a dedicated tick layer that owns both state transitions and event emission.
- **Concrete World Dependency in Runner:** The simulation runner in `main.cpp` uses `GameWorld` concrete methods (`addUnit`, `forEachUnit`, `removeDeadUnits`, etc.). `IGameWorld` exists and includes `getUnitById`, but orchestration is not yet fully expressed via interfaces.
- **Redundant State Calculation in Behaviors:** The `IBehavior` interface separates `canExecute` and `execute`. Currently, implementations (e.g., `MeleeAttackBehavior`, `MoveBehavior`) perform identical expensive checks (searching for targets, path calculation) in both methods. This results in "double work". A future optimization should pass the calculation result (context) from the check to the execution phase.

## Implementation Details
- **Randomness:** The `Random` class uses a global generator (`static std::mt19937`). For deterministic replayability or better testing, this should be replaced with an injected RNG service (e.g., passed via simulation context/world/services) with an explicit seed.
- **Movement Can Get Stuck:** The current marching logic does not attempt to route around blocking units. If the "next step" toward the target is occupied, the unit stops and may remain stuck forever. This is an intentional simplification right now, but it should be addressed (e.g., by trying alternative neighboring steps, or by introducing a simple pathing/avoidance rule).
- **Memory Usage on Large Maps:** `GameWorld` uses a dense grid representation (`std::vector<std::vector<Unit*>>`). This provides O(1) access but consumes memory proportional to `width * height`, which may be inefficient for very large, sparse maps (e.g., > 2000x2000). For such cases, a sparse spatial structure (hash map or quadtree) would be preferred.